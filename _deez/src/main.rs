use core::f64;
use std::{array, ops::Div};

use regex::Regex;
use splines::{Key,Interpolation,Spline};
use std::time;
use ndarray::prelude::*;

const CONDITION_TEST_STRING1: &str = "#1@,    , ,0.2ms    ,         ,     ,P10X, 0.2V  ,         ,   ,  ,\r";
const CONDITION_TEST_STRING2: &str = "#2@,    , ,         ,         ,     ,P1X ,       ,         ,   ,  ,\r";



const TEST_10:          [u8;10]     =   [099,160,162,163,162,163,163,163,163,163];
const TEST_10_2:        [u8;10]     =   [128,152,154,154,154,154,154,154,154,154];

const TEST_15:          [u8;15]     =   [099,160,162,163,162,163,163,163,163,163,163,163,163,163,163];
const TEST_15_2:        [u8;15]     =   [128,152,154,154,154,154,154,154,154,154,154,154,154,154,154];

const TEST_20:          [u8;20]     =   [099,160,162,163,162,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163];
const TEST_20_2:        [u8;20]     =   [128,152,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154];

const TEST_DATA_1000:   [u8;1000]   =   [128,152,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,155,155,154,155,155,154,154,154,155,155,154,154,155,155,154,155,155,155,154,155,154,155,154,155,154,154,155,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,155,154,155,155,155,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,155,155,155,155,155,155,155,155,154,154,155,154,155,155,155,155,155,155,155,154,154,155,155,155,154,155,155,155,155,155,155,154,155,155,154,155,155,155,155,154,155,155,155,154,155,155,155,155,155,155,154,146,130,129,129,129,129,129,129,129,129,129,129,128,129,129,129,128,129,129,129,129,128,128,128,128,129,129,128,129,128,128,129,128,128,129,129,128,128,129,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,129,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,129,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,129,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,129,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,146,153,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,155,154,155,154,154,155,155,155,154,155,155,155,155,155,154,155,155,155,155,155,155,154,155,155,154,155,155,155,154,155,154,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,155,154,155,155,155,155,155,155,154,155,154,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,154,155,155,155,155,155,154,155,155,155,155,155,155,133,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,128,128,129,129,129,129,129,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128];
const TEST_DATA_1000_2: [u8;1000]   =   [099,160,162,163,162,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,164,164,164,164,163,163,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,163,164,163,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,163,164,164,163,164,164,163,164,164,164,164,164,163,163,164,164,164,164,164,163,163,164,164,164,163,163,164,163,163,163,164,164,163,163,163,163,164,164,164,163,163,163,163,163,164,164,164,164,164,163,163,163,164,163,164,163,164,163,164,164,163,164,163,163,163,163,163,164,163,163,163,164,163,163,163,163,164,163,163,164,164,163,163,164,163,164,163,164,164,163,163,163,163,163,163,164,164,163,163,164,163,163,164,163,163,163,162,105,100,100,099,099,099,099,099,099,099,099,099,099,099,099,099,099,099,099,099,099,098,099,098,098,098,098,098,098,099,098,099,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,099,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,099,098,098,098,098,098,099,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,099,098,098,098,098,098,098,098,098,098,154,162,162,162,162,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,164,164,163,163,163,163,164,163,164,163,164,163,164,164,164,164,164,164,163,164,164,164,164,164,164,164,164,163,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,163,164,163,164,164,164,164,164,164,163,164,163,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,163,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,163,163,164,164,164,164,164,164,164,164,164,164,163,164,164,164,164,164,164,164,163,164,163,163,164,164,164,164,164,164,163,163,164,164,164,164,164,164,163,164,163,163,163,163,164,164,164,163,164,164,164,163,163,163,163,164,163,164,163,163,163,164,164,163,164,164,164,164,163,164,164,163,164,163,164,164,164,164,163,163,163,163,163,163,163,163,163,163,163,163,163,164,163,164,163,164,163,164,163,163,163,164,163,163,163,164,163,163,164,164,163,163,163,163,163,164,116,101,100,099,099,099,099,099,099,099,099,099,099,099,099,099,099,099,099,099,098,099,099,099,098,098,098,098,098,099,098,098,098,098,098,098,098,098,098,098,098,098,099,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,098,099,098,098];


// No.  Name                Bytes   Notes       Example 1
// ------------------------------------------------------   
// 0:   Memory Number       (3)                 #1@
// 1:   Vertical Mode       (4)     (Unused?)   ____
// 2:   Horizontal Mode     (1)     (Unused?)   _
// 3:   A Time/Div          (9)                 0.5ms____
// 4:   B Time/Div          (9)     (Unused?)   _________
// 5:   Volt Calibration    (5)                 UNCAL
// 6:   Probe Factor        (4)                 P10X
// 7:   Volts/Div           (7)                 _0.2V__
// 8:   Reserved            (9)     (Unused)    _________
// 9:   Number of Sweeps    (3)     (Unused?)   ___
// 10:  Reserved            (2)     (Unused)    __
// 11:  Delimiter           (1)                 \r

// V mV uV
// S ms us

// Relevant Data: Time/Div, Volts/Div

// simple moving average

#[derive(Clone, Default)]
pub struct ValueUnitPair {
    pub value: f64,
    pub unit_mult: f64,
    pub unit_name: String
}

pub fn scale_waveform_data(waveform_data_raw: &Vec<u8>, voltage_per_division: f32, scale_factor: f32) -> Vec<f32> {
    // This scales the raw sample data bytes to the correct voltage and time as f64s
    let mut waveform_data_scaled: Vec<f32> = vec![0.0f32;waveform_data_raw.len()];
    for (i, sample_data) in waveform_data_raw.iter().enumerate() {
        // since the zero line in the data is at 128, we need to subtract 128 to get to f64 0.0
        let voltage_y_corrected = -((*sample_data as f32) - 128.0);
        // since every y division has a size of 25, volts/div turns into volts/25
        let voltage_scaled = (voltage_y_corrected * (voltage_per_division / 25.0)) * scale_factor;
        // [time,voltage]
        waveform_data_scaled[i] = voltage_scaled;
    }
    
    waveform_data_scaled
}

pub fn moving_average_filter(samples: &Vec<f32>, window_size: usize) -> Vec<f32> {
    let mut filtered_samples: Vec<f32> = Vec::with_capacity(samples.len());
    // calculate the initial sum
    let mut sum: f32 = 0.0;

    for (i, sample) in samples.iter().enumerate() {
        if i >= window_size {
            sum -= samples[i - window_size];
        }
        if i + window_size <= samples.len() {
            sum += sample;
        }

        if i >= window_size - 1 {
            filtered_samples.push(sum / window_size as f32);
        }
    }
    while filtered_samples.len() < samples.len() {
        filtered_samples.insert(0,filtered_samples[0]);
        filtered_samples.push(filtered_samples[filtered_samples.len() - 1]);
    }
    
    filtered_samples
}


pub fn moving_average_filter4(samples: &Vec<f32>, window_size: usize) -> Vec<f32> {
    let mut filtered_samples: Vec<f32> = samples.clone();
    // calculate the initial sum
    let mut sum: f32 = 0.0;

    for (i, sample) in samples.iter().enumerate() {
        if i >= window_size {
            sum -= samples[i - window_size];
        }
        if i + window_size <= samples.len() {
            sum += sample;
        }

        if i >= window_size - 1 {
            filtered_samples[i] = sum / window_size as f32;
        }
    }
    filtered_samples
}

pub fn moving_average_filter2(samples: &Vec<f32>, window_size: usize) -> Vec<f32> {
    let mut filtered_samples = samples.clone();
    // calculate the initial sum
    let mut sum: f32 = samples[0..window_size].iter().sum();
    for i in 0..window_size {
        filtered_samples[i] = sum / window_size as f32;
    } 

    for (i, sample) in samples[window_size..samples.len()].iter().enumerate() {
        sum -= samples[i];
        if i + window_size <= samples.len() {
            sum += sample;
        }
        filtered_samples[i] = sum / window_size as f32;

    }
    filtered_samples
}

pub fn moving_average_filter3(samples: &Vec<f32>, window_size: usize) -> Vec<f32> {
    let mut filtered_samples: Vec<f32> = vec![0.0;samples.len()];
    // calculate the initial sum
    let mut sum: f32 = samples[0..window_size].iter().sum();
    for i in 0..window_size {
        filtered_samples[i] = sum / window_size as f32;
    } 

    for (i, sample) in samples[window_size..samples.len()].iter().enumerate() {
        sum -= samples[i];
        if i + window_size <= samples.len() {
            sum += sample;
        }
        filtered_samples[i] = sum / window_size as f32;

    }
    filtered_samples
}

fn main() {
    let data_float  = scale_waveform_data(&TEST_DATA_1000_2.to_vec(), 10.0, 1.0);
    let now = time::SystemTime::now();
    let mut avg: Vec<f32> = vec![0.0;1000];
    for _ in 0..1_000_000 {
        avg = moving_average_filter2(&data_float, 50);
    }
    println!("Method 1 (clone) (1_000_000 iterations): {:?}", now.elapsed());
    println!("{:?},{}", avg[420],avg.len());

    let now = time::SystemTime::now();
    for _ in 0..1_000_000 {
        avg = moving_average_filter3(&data_float, 50);
    }
    println!("Method 2 (zeroes) (1_000_000 iterations): {:?}", now.elapsed());
    println!("{:?},{}", avg[420],avg.len());

    let now = time::SystemTime::now();
    for _ in 0..1_000_000 {
        avg = moving_average_filter(&data_float, 50);
    }
    println!("Old Method (new vec) (1_000_000 iterations): {:?}", now.elapsed());
    println!("{:?},{}", avg[420],avg.len());

    let now = time::SystemTime::now();
    for _ in 0..1_000_000 {
        avg = moving_average_filter4(&data_float, 50);
    }
    println!("Old Method (clone) (1_000_000 iterations): {:?}", now.elapsed());
    println!("{:?},{}", avg[420],avg.len());
}

